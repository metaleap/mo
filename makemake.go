package main

import (
	"encoding/json"
	"io/fs"
	"os"
	"path/filepath"
	"slices"
	"strings"
)

const makefilePrelude = `# DO NOT EDIT: auto-generated by makemake.go via build_*.sh

CXX = c++
CXXFLAGS = --debug -DSDL2=1 -DLUA_USE_POSIX=1 -DWI_UNORDERED_MAP_TYPE=2 -std=c++20 -march=native -I/usr/include/SDL2


`

var (
	strEnds      = strings.HasSuffix
	strBegins    = strings.HasPrefix
	everLibNames = map[string][]string{
		"mo2d":             {"noise", "imgui", "imgui-sfml", "sfml-graphics", "sfml-window", "sfml-system", "GL"},
		"mo3d":             {"imgui", "SDL2", "WickedEngine"},
		"mo_noiselib_tuts": {"noise", "imgui"},
	}
)

type makeRule struct {
	outPath      string
	inPath       string
	depPaths     []string
	inclDirPaths []string
}

type clangCompileCommand struct {
	Dir  string   `json:"directory"`
	File string   `json:"file"`
	Args []string `json:"arguments"`
}

func main() {
	var clang_compile_commands []clangCompileCommand
	prog_names := os.Args[1:]
	cur_dir_path := fsAbs(".")
	var all_source_file_paths []string
	mo_obj_paths := map[string]bool{}
	fs.WalkDir(os.DirFS(cur_dir_path), ".", func(fsPath string, fsEntry fs.DirEntry, err error) error {
		if err != nil {
			panic(err)
		}
		if is_cpp, is_h := strEnds(fsPath, ".cpp"), strEnds(fsPath, ".h"); strBegins(fsPath, "mo") && (!fsEntry.IsDir()) && (is_cpp || is_h) {
			all_source_file_paths = append(all_source_file_paths, fsPath)
			if strBegins(fsPath, "mo/") {
				mo_obj_paths[fsCppPathToObjPath(fsPath)] = true
			}
			if is_cpp {
				clang_compile_commands = append(clang_compile_commands, clangCompileCommand{
					Dir:  cur_dir_path,
					File: fsPath,
					Args: []string{"c++",
						"-DSDL2=1", "-DLUA_USE_POSIX=1", "-DWI_UNORDERED_MAP_TYPE=2",
						"-I/usr/include/SDL2", "--debug", "-std=c++20", "-march=native",
						"-c", "-g", "-O0", fsPath, "-o", "/dev/null/dummy"},
				})
			}
		}
		return nil
	})

	var rules []makeRule
	for _, source_file_path := range all_source_file_paths {
		if strEnds(source_file_path, ".cpp") {
			rule := makeRule{inPath: source_file_path, outPath: fsCppPathToObjPath(source_file_path)}
			src := fsRead(rule.inPath)
			for again, needle_incl := true, "#include \""; again; {
				idx_incl := strings.LastIndex(src, needle_incl)
				if again = (idx_incl >= 0); again {
					idx_off := idx_incl + len(needle_incl)
					idx_quot := strings.IndexByte(src[idx_off:], '"')
					if again, idx_quot = (idx_quot > 0), idx_off+idx_quot; again {
						h_file_path := filepath.Join(filepath.Dir(rule.inPath), src[idx_off:idx_quot])
						cpp_file_path := h_file_path[:len(h_file_path)-len(".h")] + ".cpp"
						for _, src_file_path := range []string{h_file_path, cpp_file_path} {
							if fsIsFile(src_file_path) && slices.Index(rule.depPaths, src_file_path) < 0 {
								rule.depPaths = append(rule.depPaths, src_file_path)
							}
						}
						src = src[:idx_incl]
					}
				}
			}
			rules = append(rules, rule)
		}
	}

	var buf strings.Builder
	buf.WriteString(makefilePrelude)
	{
		for _, rule := range rules {
			for _, prog_name := range prog_names {
				if rule.outPath == "bin/"+prog_name+"_main.o" {
					obj_file_paths, is_first := []string{rule.outPath}, true
					for _, src_file_path := range all_source_file_paths {
						if strEnds(src_file_path, ".cpp") && strBegins(src_file_path, prog_name+"/") {
							obj_file_paths = append(obj_file_paths, "bin/"+fsCppPathToObjName(src_file_path)+".o")
						}
					}
					slices.Sort(obj_file_paths)
					obj_file_paths = slices.Compact(obj_file_paths)

					buf.WriteString("bin/" + prog_name + ".exec")
					for _, obj_file_path := range obj_file_paths {
						buf.WriteString(iIf(is_first, ": ", " ") + obj_file_path)
						is_first = false
					}
					for obj_file_path := range mo_obj_paths {
						buf.WriteString(" " + obj_file_path)
					}
					buf.WriteByte('\n')
					buf.WriteString("\t$(CXX) $(CXXFLAGS) -Lbin")
					for _, lib_name := range everLibNames[prog_name] {
						buf.WriteString(" -l" + lib_name)
					}
					for _, obj_file_path := range obj_file_paths {
						buf.WriteString(" " + obj_file_path)
					}
					for obj_file_path := range mo_obj_paths {
						buf.WriteString(" " + obj_file_path)
					}
					buf.WriteString(" -o bin/" + prog_name + ".exec\n")
					buf.WriteByte('\n')
					break
				}
			}
		}
	}
	{
		buf.WriteString(`
clean:
	rm -f bin/*.o
	rm -f bin/*.exec
# NOTE on clean: bin isn't to be emptied, all bin/*.so files _stay_! they're rarely or never updated 3rd-party deps, and they're rebuilt not with this generated makefile but the manually-written sibline one.
`)
		buf.WriteByte('\n')
	}
	for _, rule := range rules {
		buf.WriteString(rule.outPath + ": " + rule.inPath)
		for _, dep := range rule.depPaths {
			buf.WriteString(" " + dep)
		}
		buf.WriteString("\n\t$(CXX) -c $(CXXFLAGS)")
		for _, lib_dep_dir_path := range libdep_incl_dirpaths {
			buf.WriteString(" -I" + lib_dep_dir_path)
		}
		buf.WriteString(" " + rule.inPath + " -o " + rule.outPath + "\n")
		buf.WriteByte('\n')
	}
	fsWrite("makefile", buf.String())

	incl_args := make([]string, len(libdep_incl_dirpaths))
	for i, lib_dep_dir_path := range libdep_incl_dirpaths {
		incl_args[i] = "-I" + lib_dep_dir_path
	}
	for i, ccc := range clang_compile_commands {
		ccc.Args = append(ccc.Args[:1], append(incl_args, ccc.Args[1:]...)...)
		clang_compile_commands[i] = ccc
	}
	src_clang_compile_commands, _ := json.MarshalIndent(clang_compile_commands, "", "  ")
	fsWrite("compile_commands.json", string(src_clang_compile_commands))
}

func iIf[T any](b bool, t T, f T) T {
	if b {
		return t
	}
	return f
}

func fsCppPathToObjPath(fsPath string) string {
	return "bin/" + fsCppPathToObjName(fsPath) + ".o"
}

func fsCppPathToObjName(fsPath string) string {
	idx := strings.LastIndexByte(fsPath, '.')
	return strings.ReplaceAll(fsPath[:idx], "/", "_")
}

func fsIsFile(fsPath string) bool {
	stat, err := os.Stat(fsPath)
	return (err == nil) && (stat != nil) && !stat.IsDir()
}

func fsRead(fsPath string) string {
	raw, err := os.ReadFile(fsPath)
	if err != nil {
		panic(err)
	}
	return string(raw)
}

func fsWrite(fsPath string, src string) {
	err := os.WriteFile(fsPath, []byte(src), os.ModePerm)
	if err != nil {
		panic(err)
	}
}

func fsAbs(fsPath string) string {
	ret, err := filepath.Abs(fsPath)
	if err != nil {
		panic(err)
	}
	return ret
}
