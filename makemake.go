package main

import (
	"encoding/json"
	"io/fs"
	"os"
	"path/filepath"
	"slices"
	"strings"
)

const makefilePrelude = `# DO NOT EDIT: auto-generated by makemake.go via build_*.sh

CXX = g++
CXXFLAGS = --debug -std=c++20 -march=native


`

var (
	strEnds      = strings.HasSuffix
	strBegins    = strings.HasPrefix
	everLibNames = map[string][]string{
		"mo2d":             {"imgui", "imgui-sfml", "sfml-graphics", "sfml-window", "sfml-system", "GL"},
		"mo_noiselib_tuts": {"noise"},
	}
)

type makeRule struct {
	outPath  string
	inPath   string
	depPaths []string
}

type clangCompileCommand struct {
	Dir  string   `json:"directory"`
	File string   `json:"file"`
	Args []string `json:"arguments"`
}

func main() {
	var clang_compile_commands []clangCompileCommand
	prog_names := os.Args[1:]
	var lib_dep_dir_paths []string
	cur_dir_path := fsAbs(".")
	var all_source_file_paths []string
	fs.WalkDir(os.DirFS(cur_dir_path), ".", func(fsPath string, fsEntry fs.DirEntry, err error) error {
		if err != nil {
			panic(err)
		}
		if fsEntry.IsDir() && strBegins(fsPath, "libdeps/") && (!strings.Contains(fsPath, "/examples/")) && !strEnds(strings.TrimRight(fsPath, "/"), "/examples") {
			if matches1, err := filepath.Glob(filepath.Join(fsPath, "*.h")); err != nil {
				panic(err)
			} else if matches2, err := filepath.Glob(filepath.Join(fsPath, "**", "*.h")); err != nil {
				panic(err)
			} else if (len(matches1) > 0) || (len(matches2) > 0) {
				lib_dep_dir_paths = append(lib_dep_dir_paths, fsPath)
			}
		}
		if !strBegins(fsPath, "mo") {
			return nil
		} else if (strings.Count(fsPath, "/") == 1) && strEnds(fsPath, "/main.cpp") {
			clang_compile_commands = append(clang_compile_commands, clangCompileCommand{
				Dir:  cur_dir_path,
				File: fsPath,
				Args: []string{"clang++", "-std=c++20", "-c", "-g", "-O0", fsPath, "-o", "/dev/null/dummy"},
			})
		}
		if (!fsEntry.IsDir()) && (strEnds(fsPath, ".cpp") || strEnds(fsPath, ".h")) {
			all_source_file_paths = append(all_source_file_paths, fsPath)
		}
		return nil
	})

	var rules []makeRule
	for _, source_file_path := range all_source_file_paths {
		if strEnds(source_file_path, ".cpp") {
			rule := makeRule{inPath: source_file_path, outPath: fsCppPathToObjPath(source_file_path)}
			src := fsRead(rule.inPath)
			for again, needle_incl := true, "#include \""; again; {
				idx_incl := strings.LastIndex(src, needle_incl)
				if again = (idx_incl >= 0); again {
					idx_off := idx_incl + len(needle_incl)
					idx_quot := strings.IndexByte(src[idx_off:], '"')
					if again, idx_quot = (idx_quot > 0), idx_off+idx_quot; again {
						h_file_path := filepath.Join(filepath.Dir(rule.inPath), src[idx_off:idx_quot])
						cpp_file_path := h_file_path[:len(h_file_path)-len(".h")] + ".cpp"
						for _, src_file_path := range []string{h_file_path, cpp_file_path} {
							if fsIsFile(src_file_path) && slices.Index(rule.depPaths, src_file_path) < 0 {
								rule.depPaths = append(rule.depPaths, src_file_path)
							}
						}
						src = src[:idx_incl]
					}
				}
			}
			rules = append(rules, rule)
		}
	}

	var buf strings.Builder
	buf.WriteString(makefilePrelude)
	for _, rule := range rules {
		for _, prog_name := range prog_names {
			if rule.outPath == "bin/"+prog_name+"_main.o" {
				obj_file_paths, is_first := map[string]bool{rule.outPath: true}, true
				for _, src_file_path := range all_source_file_paths {
					if strEnds(src_file_path, ".cpp") && strBegins(src_file_path, prog_name+"/") {
						obj_file_paths["bin/"+fsCppPathToObjName(src_file_path)+".o"] = true
					}
				}

				buf.WriteString("bin/" + prog_name + ".exec")
				for obj_file_path := range obj_file_paths {
					buf.WriteString(iIf(is_first, ": ", " ") + obj_file_path)
					is_first = false
				}
				buf.WriteByte('\n')
				buf.WriteString("\t$(CXX) $(CXXFLAGS) -Lbin")
				for _, lib_name := range everLibNames[prog_name] {
					buf.WriteString(" -l" + lib_name)
				}
				for obj_file_path := range obj_file_paths {
					buf.WriteString(" " + obj_file_path)
				}
				buf.WriteString(" -o bin/" + prog_name + ".exec\n")
				buf.WriteByte('\n')
				break
			}
		}
	}
	{
		buf.WriteString(`
clean:
	rm -f bin/*.o
	rm -f bin/*.exec
# NOTE on clean: bin isn't to be emptied, all bin/*.so files _stay_! they're rarely or never updated 3rd-party deps, and they're rebuilt not with this generated makefile but the manually-written sibline one.
`)
		buf.WriteByte('\n')
	}
	for _, rule := range rules {
		buf.WriteString(rule.outPath + ": " + rule.inPath)
		for _, dep := range rule.depPaths {
			buf.WriteString(" " + dep)
		}
		buf.WriteString("\n\t$(CXX) -c $(CXXFLAGS)")
		for _, lib_dep_dir_path := range lib_dep_dir_paths {
			buf.WriteString(" -I" + lib_dep_dir_path)
		}
		buf.WriteString(" " + rule.inPath + " -o " + rule.outPath + "\n")
		buf.WriteByte('\n')
	}
	fsWrite("makefile", buf.String())

	incl_args := make([]string, len(lib_dep_dir_paths))
	for i, lib_dep_dir_path := range lib_dep_dir_paths {
		incl_args[i] = "-I" + lib_dep_dir_path
	}
	for i, ccc := range clang_compile_commands {
		ccc.Args = append(ccc.Args[:1], append(incl_args, ccc.Args[1:]...)...)
		clang_compile_commands[i] = ccc
	}
	src_clang_compile_commands, _ := json.MarshalIndent(clang_compile_commands, "", "  ")
	fsWrite("compile_commands.json", string(src_clang_compile_commands))
}

func iIf[T any](b bool, t T, f T) T {
	if b {
		return t
	}
	return f
}

func fsCppPathToObjPath(fsPath string) string {
	return "bin/" + fsCppPathToObjName(fsPath) + ".o"
}

func fsCppPathToObjName(fsPath string) string {
	idx := strings.LastIndexByte(fsPath, '.')
	return strings.ReplaceAll(fsPath[:idx], "/", "_")
}

func fsIsFile(fsPath string) bool {
	stat, err := os.Stat(fsPath)
	return (err == nil) && (stat != nil) && !stat.IsDir()
}

func fsRead(fsPath string) string {
	raw, err := os.ReadFile(fsPath)
	if err != nil {
		panic(err)
	}
	return string(raw)
}

func fsWrite(fsPath string, src string) {
	err := os.WriteFile(fsPath, []byte(src), os.ModePerm)
	if err != nil {
		panic(err)
	}
}

func fsAbs(fsPath string) string {
	ret, err := filepath.Abs(fsPath)
	if err != nil {
		panic(err)
	}
	return ret
}
